# 复合数据类型

## 数组
数组是具有固定长度且拥有零个或者多个相同数据类型元素的序列。

默认情况下，一个新数组中的元素初始值位元素类型的零值，也可以使用数组字面量根据一组值来初始化一个数组。
在数组字面量中，如果省略号 “...” 出现在数据长度的位置，那么数组的长度由初始化数组的元素个数决定。

```go
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}
fmt.Println(r[2]) // "0"

q := [...]int{1, 2, 3}
fmt.Printf("%T\n", q) // "[3]int"

type Currency int
const (
    USD Currency = iota
    EUR
    GBP
    RMB
)
symbol := [...]string{USD: "$", EUR: "€", GBP: "£", RMB: "¥"}
```

数组的长度是数组类型的一部分，所以 [3]int 和 [4]int 是两种不同的数据类型。

```go
q := [3]int{1, 2, 3}
q = [4]int{1, 2, 3, 4}  // 编译错误：不可以将 [4]int 赋值给 [3]int
```

如果一个数组的元素类型是可比较的，那么这个数组也是可比较的，这样我们就可以直接使用 == 和 != 来比较数组两边元素的值是否完全相同。

```go
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
d := [3]int{1, 2}
fmt.Println(a == b, a == c, b == c) // “true, false, false”
fmt.Println(a == d) // 编译错误：无法比较 [2]int == [3]int
```

> 当调用一个函数的时候，每个传入的参数都会创建一个副本，然后赋值给对应的函数变量，所以函数接受的是一个副本，
> 而不是原始的参数。使用这种方式传递大的数组会变得很低效，并且在数组内部对数组的任何修改都仅影响副本，而不是原始数组。
> 这种情况下，Go 把数组和其它类型都看成值传递。而在其它的语言中，数组是隐式地使用引用传递。


## slice
slice 表示一个拥有相同类型元素的可变长度的序列。slice 通常写成 `[]T`，其中元素的类型都是 T；它看上去像没有长度的数组类型。